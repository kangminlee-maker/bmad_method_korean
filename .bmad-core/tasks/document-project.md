# 기존 프로젝트 문서화

## 목적

AI 개발 에이전트를 위해 최적화된 기존 프로젝트의 포괄적인 문서를 생성합니다. 이 작업은 AI 에이전트가 프로젝트 컨텍스트, 관례, 패턴을 이해하여 모든 코드베이스에 효과적으로 기여할 수 있도록 구조화된 참조 자료를 생성합니다.

## 작업 지침

### 1. 초기 프로젝트 분석

**중요:** 먼저 PRD나 요구사항 문서가 컨텍스트에 존재하는지 확인하세요. 있다면 관련 영역에만 문서화 노력을 집중하는 데 사용하세요.

**PRD가 있는 경우**:

- PRD를 검토하여 계획된 개선/기능 이해
- 영향을 받을 모듈, 서비스 또는 영역 식별
- 이러한 관련 영역에만 문서화 집중
- 문서를 간결하게 유지하기 위해 코드베이스의 관련 없는 부분 건너뛰기

**PRD가 없는 경우**:
사용자에게 문의:

"PRD나 요구사항 문서를 제공하지 않으신 것 같습니다. 더 집중적이고 유용한 문서를 만들기 위해 다음 옵션 중 하나를 권장합니다:

1. **먼저 PRD 생성** - 문서화 전에 브라운필드 PRD를 만드는 것을 도와드릴까요? 이는 관련 영역에 문서화를 집중하는 데 도움이 됩니다.

2. **기존 요구사항 제공** - 공유할 수 있는 요구사항 문서, 에픽 또는 기능 설명이 있으신가요?

3. **초점 설명** - 계획 중인 개선 사항이나 기능을 간단히 설명해 주실 수 있나요? 예를 들어:
   - '사용자 서비스에 결제 처리 추가'
   - '인증 모듈 리팩토링'
   - '새로운 타사 API와 통합'

4. **모든 것 문서화** - 아니면 전체 코드베이스의 포괄적인 문서화를 진행할까요? (참고: 대규모 프로젝트의 경우 과도한 문서가 생성될 수 있습니다)

선호하시는 옵션을 알려주시거나, 원하시면 전체 문서화를 진행할 수 있습니다."

응답에 따라:

- 옵션 1-3을 선택한 경우: 해당 컨텍스트를 사용하여 문서화 집중
- 옵션 4를 선택하거나 거부한 경우: 아래의 포괄적인 분석 진행

기존 프로젝트의 분석을 시작합니다. 사용 가능한 도구를 사용하여:

1. **프로젝트 구조 발견**: 루트 디렉토리 구조 검토, 주요 폴더 식별, 전체 구성 이해
2. **기술 스택 식별**: package.json, requirements.txt, Cargo.toml, pom.xml 등을 찾아 언어, 프레임워크, 의존성 식별
3. **빌드 시스템 분석**: 빌드 스크립트, CI/CD 구성, 개발 명령 찾기
4. **기존 문서 검토**: README 파일, docs 폴더, 기존 문서 확인
5. **코드 패턴 분석**: 주요 파일을 샘플링하여 코딩 패턴, 명명 규칙, 아키텍처 접근법 이해

사용자의 요구를 더 잘 이해하기 위해 다음 유도 질문을 하세요:

- 이 프로젝트의 주요 목적은 무엇인가요?
- 에이전트가 이해해야 할 특히 복잡하거나 중요한 코드베이스 영역이 있나요?
- AI 에이전트가 이 프로젝트에서 수행할 것으로 예상되는 작업 유형은 무엇인가요? (예: 버그 수정, 기능 추가, 리팩토링, 테스트)
- 선호하는 기존 문서 표준이나 형식이 있나요?
- 문서가 대상으로 해야 할 기술적 세부 수준은 어느 정도인가요? (주니어 개발자, 시니어 개발자, 혼합 팀)
- 계획 중인 특정 기능이나 개선 사항이 있나요? (이는 문서화를 집중하는 데 도움이 됩니다)

### 2. 심층 코드베이스 분석

중요: 문서를 생성하기 전에 기존 코드베이스의 광범위한 분석을 수행합니다:

1. **주요 영역 탐색**:
   - 진입점 (메인 파일, 인덱스 파일, 앱 초기화자)
   - 구성 파일 및 환경 설정
   - 패키지 의존성 및 버전
   - 빌드 및 배포 구성
   - 테스트 스위트 및 커버리지

2. **명확화 질문 하기**:
   - "[기술 X]를 사용하시는 것을 보았습니다. 문서화해야 할 사용자 정의 패턴이나 규칙이 있나요?"
   - "개발자들이 어려워하는 이 시스템의 가장 중요하고 복잡한 부분은 무엇인가요?"
   - "캡처해야 할 문서화되지 않은 '부족 지식' 영역이 있나요?"
   - "문서화해야 할 기술 부채나 알려진 문제는 무엇인가요?"
   - "코드베이스의 어느 부분이 가장 자주 변경되나요?"

3. **현실 매핑**:
   - 사용된 실제 패턴 식별 (이론적 모범 사례가 아님)
   - 핵심 비즈니스 로직이 있는 위치 찾기
   - 통합 지점 및 외부 의존성 찾기
   - 해결 방법 및 기술 부채 문서화
   - 표준 패턴과 다른 영역 기록

**PRD가 제공된 경우**: 개선을 위해 변경해야 할 사항도 분석

### 3. 핵심 문서 생성

[[LLM: 코드베이스의 실제 상태를 반영하는 포괄적인 브라운필드 아키텍처 문서를 생성합니다.

**중요**: 이것은 열망적인 아키텍처 문서가 아닙니다. 다음을 포함하여 존재하는 것을 문서화합니다:

- 기술 부채 및 해결 방법
- 서로 다른 부분 간의 일관되지 않은 패턴
- 변경할 수 없는 레거시 코드
- 통합 제약
- 성능 병목 현상

**문서 구조**:

# [프로젝트 이름] 브라운필드 아키텍처 문서

## 소개

이 문서는 기술 부채, 해결 방법 및 실제 패턴을 포함하여 [프로젝트 이름] 코드베이스의 현재 상태를 캡처합니다. 개선 작업을 하는 AI 에이전트를 위한 참조 자료로 사용됩니다.

### 문서 범위

[PRD 제공된 경우: "다음과 관련된 영역에 초점: {개선 설명}"]
[PRD 없는 경우: "전체 시스템의 포괄적인 문서"]

### 변경 로그

| 날짜   | 버전 | 설명                 | 작성자    |
| ------ | ---- | -------------------- | --------- |
| [날짜] | 1.0  | 초기 브라운필드 분석 | [분석가] |

## 빠른 참조 - 주요 파일 및 진입점

### 시스템 이해를 위한 중요 파일

- **메인 진입점**: `src/index.js` (또는 실제 진입점)
- **구성**: `config/app.config.js`, `.env.example`
- **핵심 비즈니스 로직**: `src/services/`, `src/domain/`
- **API 정의**: `src/routes/` 또는 OpenAPI 사양 링크
- **데이터베이스 모델**: `src/models/` 또는 스키마 파일 링크
- **주요 알고리즘**: [복잡한 로직이 있는 특정 파일 나열]

### PRD 제공된 경우 - 개선 영향 영역

[계획된 개선에 의해 영향을 받을 파일/모듈 강조]

## 고수준 아키텍처

### 기술 요약

### 실제 기술 스택 (package.json/requirements.txt에서)

| 카테고리  | 기술       | 버전   | 참고사항                   |
| --------- | ---------- | ------ | -------------------------- |
| 런타임    | Node.js    | 16.x   | [제약사항]                 |
| 프레임워크 | Express    | 4.18.2 | [사용자 정의 미들웨어?]     |
| 데이터베이스 | PostgreSQL | 13     | [연결 풀 설정]             |

등...

### 저장소 구조 현실 확인

- 유형: [모노레포/폴리레포/하이브리드]
- 패키지 관리자: [npm/yarn/pnpm]
- 주목할 점: [비정상적인 구조 결정]

## 소스 트리 및 모듈 구성

### 프로젝트 구조 (실제)

```text
project-root/
├── src/
│   ├── controllers/     # HTTP 요청 핸들러
│   ├── services/        # 비즈니스 로직 (참고: 사용자와 결제 서비스 간 일관되지 않은 패턴)
│   ├── models/          # 데이터베이스 모델 (Sequelize)
│   ├── utils/           # 잡동사니 - 리팩토링 필요
│   └── legacy/          # 수정 금지 - 구 결제 시스템 여전히 사용 중
├── tests/               # Jest 테스트 (60% 커버리지)
├── scripts/             # 빌드 및 배포 스크립트
└── config/              # 환경 구성
```

### 주요 모듈 및 목적

- **사용자 관리**: `src/services/userService.js` - 모든 사용자 작업 처리
- **인증**: `src/middleware/auth.js` - JWT 기반, 사용자 정의 구현
- **결제 처리**: `src/legacy/payment.js` - 중요: 리팩토링 금지, 강하게 결합됨
- **[실제 파일과 함께 다른 주요 모듈 나열]**

## 데이터 모델 및 API

### 데이터 모델

중복 대신 실제 모델 파일 참조:

- **사용자 모델**: `src/models/User.js` 참조
- **주문 모델**: `src/models/Order.js` 참조
- **관련 타입**: `src/types/`의 TypeScript 정의

### API 사양

- **OpenAPI 사양**: `docs/api/openapi.yaml` (존재하는 경우)
- **Postman 컬렉션**: `docs/api/postman-collection.json`
- **수동 엔드포인트**: [발견된 문서화되지 않은 엔드포인트 나열]

## 기술 부채 및 알려진 문제

### 중요한 기술 부채

1. **결제 서비스**: `src/legacy/payment.js`의 레거시 코드 - 강하게 결합됨, 테스트 없음
2. **사용자 서비스**: 다른 서비스와 다른 패턴, 프로미스 대신 콜백 사용
3. **데이터베이스 마이그레이션**: 수동으로 추적됨, 적절한 마이그레이션 도구 없음
4. **[기타 중요한 부채]**

### 해결 방법 및 함정

- **환경 변수**: 스테이징에서도 `NODE_ENV=production` 설정 필수 (역사적 이유)
- **데이터베이스 연결**: 연결 풀이 10으로 하드코딩됨, 변경 시 결제 서비스 중단
- **[개발자가 알아야 할 다른 해결 방법]**

## 통합 지점 및 외부 의존성

### 외부 서비스

| 서비스   | 목적   | 통합 유형 | 주요 파일                      |
| -------- | ------ | --------- | ------------------------------ |
| Stripe   | 결제   | REST API  | `src/integrations/stripe/`     |
| SendGrid | 이메일 | SDK       | `src/services/emailService.js` |

등...

### 내부 통합 지점

- **프런트엔드 통신**: 포트 3000의 REST API, 특정 헤더 예상
- **백그라운드 작업**: Redis 큐, `src/workers/` 참조
- **[기타 통합]**

## 개발 및 배포

### 로컬 개발 설정

1. 실제로 작동하는 단계 (이상적인 단계가 아님)
2. 설정 시 알려진 문제
3. 필요한 환경 변수 (`.env.example` 참조)

### 빌드 및 배포 프로세스

- **빌드 명령**: `npm run build` (webpack 구성은 `webpack.config.js`에)
- **배포**: `scripts/deploy.sh`를 통한 수동 배포
- **환경**: 개발, 스테이징, 프로덕션 (`config/environments/` 참조)

## 테스트 현실

### 현재 테스트 커버리지

- 단위 테스트: 60% 커버리지 (Jest)
- 통합 테스트: 최소한, `tests/integration/`에
- E2E 테스트: 없음
- 수동 테스트: 주요 QA 방법

### 테스트 실행

```bash
npm test           # 단위 테스트 실행
npm run test:integration  # 통합 테스트 실행 (로컬 DB 필요)
```

## 개선 PRD 제공된 경우 - 영향 분석

### 수정이 필요한 파일

개선 요구사항에 따라 다음 파일이 영향을 받습니다:

- `src/services/userService.js` - 새 사용자 필드 추가
- `src/models/User.js` - 스키마 업데이트
- `src/routes/userRoutes.js` - 새 엔드포인트
- [등...]

### 필요한 새 파일/모듈

- `src/services/newFeatureService.js` - 새 비즈니스 로직
- `src/models/NewFeature.js` - 새 데이터 모델
- [등...]

### 통합 고려사항

- 기존 인증 미들웨어와 통합 필요
- `src/utils/responseFormatter.js`의 기존 응답 형식을 따라야 함
- [기타 통합 지점]

## 부록 - 유용한 명령 및 스크립트

### 자주 사용하는 명령

```bash
npm run dev         # 개발 서버 시작
npm run build       # 프로덕션 빌드
npm run migrate     # 데이터베이스 마이그레이션 실행
npm run seed        # 테스트 데이터 시드
```

### 디버깅 및 문제 해결

- **로그**: 애플리케이션 로그는 `logs/app.log` 확인
- **디버그 모드**: 상세 로깅을 위해 `DEBUG=app:*` 설정
- **일반적인 문제**: `docs/troubleshooting.md` 참조]]

### 4. 문서 전달

1. **웹 UI에서 (Gemini, ChatGPT, Claude)**:
   - 전체 문서를 하나의 응답으로 제시 (너무 길면 여러 개로)
   - 사용자에게 복사하여 `docs/brownfield-architecture.md` 또는 `docs/project-architecture.md`로 저장하도록 안내
   - 필요시 나중에 IDE에서 분할할 수 있다고 언급

2. **IDE 환경에서**:
   - `docs/brownfield-architecture.md`로 문서 생성
   - 이 단일 문서에 모든 아키텍처 정보가 포함되어 있음을 사용자에게 알림
   - 원한다면 나중에 PO 에이전트를 사용하여 분할 가능

문서는 미래의 에이전트가 다음을 이해할 수 있을 만큼 포괄적이어야 합니다:

- 시스템의 실제 상태 (이상화되지 않은)
- 주요 파일과 로직을 찾을 위치
- 존재하는 기술 부채
- 준수해야 할 제약사항
- PRD 제공된 경우: 개선을 위해 변경해야 할 사항]]

### 5. 품질 보증

중요: 문서를 확정하기 전에:

1. **정확성 확인**: 모든 기술 세부사항이 실제 코드베이스와 일치하는지 확인
2. **완전성 검토**: 모든 주요 시스템 구성요소가 문서화되었는지 확인
3. **초점 검증**: 사용자가 범위를 제공한 경우 관련 영역이 강조되었는지 확인
4. **명확성 평가**: AI 에이전트를 위한 설명이 명확한지 확인
5. **탐색**: 문서가 쉬운 참조를 위한 명확한 섹션 구조를 가지고 있는지 확인

사용자 피드백을 기반으로 개선하기 위해 주요 섹션 후에 고급 유도 작업을 적용하세요.

## 성공 기준

- 단일 포괄적 브라운필드 아키텍처 문서 생성
- 문서가 기술 부채와 해결 방법을 포함한 현실 반영
- 주요 파일과 모듈이 실제 경로로 참조됨
- 모델/API가 콘텐츠를 복제하지 않고 소스 파일 참조
- PRD 제공된 경우: 변경해야 할 사항을 보여주는 명확한 영향 분석
- 문서가 AI 에이전트가 실제 코드베이스를 탐색하고 이해할 수 있게 함
- 기술적 제약과 "함정"이 명확하게 문서화됨

## 참고사항

- 이 작업은 시스템의 진실된 상태를 캡처하는 하나의 문서를 생성합니다
- 가능한 경우 콘텐츠를 복제하지 않고 실제 파일 참조
- 기술 부채, 해결 방법, 제약사항을 정직하게 문서화
- PRD가 있는 브라운필드 프로젝트의 경우: 명확한 개선 영향 분석 제공
- 목표는 실제 작업을 수행하는 AI 에이전트를 위한 실용적 문서입니다
